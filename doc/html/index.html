<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diligent Engine API Reference: DiligentCore</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Diligent Engine API Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">DiligentCore </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This module implements key engine functionality. It provides API implementations with Direct3D11, Direct3D12, OpenGL and OpenGLES as well as basic platform-specific utilities.</p>
<h1>Build Status</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Platform  </th><th class="markdownTableHeadNone">Status   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Win32/Universal Windows  </td><td class="markdownTableBodyNone"><a href="https://ci.appveyor.com/project/DiligentGraphics/diligentcore"></a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Linux  </td><td class="markdownTableBodyNone"><a href="https://travis-ci.org/DiligentGraphics/DiligentCore"></a>   </td></tr>
</table>
<h1>Repository structure</h1>
<p>The repository contains the following projects:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Project  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="/Primitives">Primitives</a>  </td><td class="markdownTableBodyNone">Definitions of basic types (Int32, Int16, Uint32, etc.) and interfaces (IObject, IReferenceCounters, etc.)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="/Common">Common</a>  </td><td class="markdownTableBodyNone">Common functionality such as file wrapper, logging, debug utilities, etc.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="Graphics/GraphicsAccessories">Graphics/GraphicsAccessories</a>  </td><td class="markdownTableBodyNone">Basic graphics accessories used by all implementations   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="Graphics/GraphicsEngine">Graphics/GraphicsEngine</a>  </td><td class="markdownTableBodyNone">Platform-independent base functionality   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="Graphics/GraphicsEngineD3DBase">Graphics/GraphicsEngineD3DBase</a>  </td><td class="markdownTableBodyNone">Base functionality for D3D11/D3D12 implementations   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="Graphics/GraphicsEngineD3D11">Graphics/GraphicsEngineD3D11</a>  </td><td class="markdownTableBodyNone">Engine implementation with Direct3D11   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="Graphics/GraphicsEngineD3D12">Graphics/GraphicsEngineD3D12</a>  </td><td class="markdownTableBodyNone">Engine implementation with Direct3D12   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="Graphics/GraphicsEngineOpenGL">Graphics/GraphicsEngineOpenGL</a>  </td><td class="markdownTableBodyNone">Engine implementation with OpenGL/GLES   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="Graphics/GraphicsTools">Graphics/GraphicsTools</a>  </td><td class="markdownTableBodyNone">Graphics utilities build on top of core interfaces (definitions of commonly used states, texture uploaders, etc.)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="Graphics/HLSL2GLSLConverterLib">Graphics/HLSL2GLSLConverterLib</a>  </td><td class="markdownTableBodyNone">HLSL to GLSL source code converter library   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="Platforms/Basic">Platforms/Basic</a>  </td><td class="markdownTableBodyNone">Interface for platform-specific routines and implementation of some common functionality   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="Platforms/Android">Platforms/Android</a>  </td><td class="markdownTableBodyNone">Implementation of platform-specific routines on Android   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="Platforms/UWP">Platforms/UWP</a>  </td><td class="markdownTableBodyNone">Implementation of platform-specific routines on Universal Windows platform   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="Platforms/Win32">Platforms/Win32</a>  </td><td class="markdownTableBodyNone">Implementation of platform-specific routines on Win32 platform   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="Platforms/Linux">Platforms/Linux</a>  </td><td class="markdownTableBodyNone">Implementation of platform-specific routines on Linux platform   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">External/glew  </td><td class="markdownTableBodyNone">Cross-platform library for loading OpenGL extensions   </td></tr>
</table>
<h1>API Basics</h1>
<h2>Initializing the Engine</h2>
<p>Before you can use any functionality provided by the engine, you need to create a render device, an immediate context and a swap chain.</p>
<h3>Win32</h3>
<p>On Win32 platform, you can create OpenGL, Direct3D11 or Direct3D12 device as shown below:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> InitDevice(HWND hWnd, </div><div class="line">                IRenderDevice **ppRenderDevice, </div><div class="line">                IDeviceContext **ppImmediateContext,  </div><div class="line">                ISwapChain **ppSwapChain, </div><div class="line">                DeviceType DevType)</div><div class="line">{</div><div class="line">    SwapChainDesc SCDesc;</div><div class="line">    SCDesc.<a class="code" href="struct_diligent_1_1_swap_chain_desc.html#abb6c480f76a89a38333249970fc0c6d9">SamplesCount</a> = 1;</div><div class="line">    <span class="keywordflow">switch</span> (DevType)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> DeviceType::D3D11:</div><div class="line">        {</div><div class="line">            EngineD3D11Attribs DeviceAttribs;</div><div class="line">            DeviceAttribs.<a class="code" href="struct_diligent_1_1_engine_d3_d11_attribs.html#ae45ccd8517116ee19b002f85e80bf1b4">DebugFlags</a> = (Uint32)EngineD3D11DebugFlags::VerifyCommittedShaderResources |</div><div class="line">                                       (Uint32)EngineD3D11DebugFlags::VerifyCommittedResourceRelevance;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef ENGINE_DLL</span></div><div class="line">            GetEngineFactoryD3D11Type GetEngineFactoryD3D11 = <span class="keyword">nullptr</span>;</div><div class="line">            <span class="comment">// Load the dll and import GetEngineFactoryD3D11() function</span></div><div class="line">            <a class="code" href="namespace_diligent.html#adfb2dafb678f595c8c1300cf53d14a15">LoadGraphicsEngineD3D11</a>(GetEngineFactoryD3D11);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">            <span class="keyword">auto</span> *pFactoryD3D11 = GetEngineFactoryD3D11();</div><div class="line">            pFactoryD3D11-&gt;CreateDeviceAndContextsD3D11( DeviceAttribs, ppRenderDevice, ppImmediateContext, 0 );</div><div class="line">            pFactoryD3D11-&gt;CreateSwapChainD3D11( *ppRenderDevice, *ppImmediateContext, SCDesc, hWnd, ppSwapChain );</div><div class="line">        }</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> DeviceType::D3D12:</div><div class="line">        {</div><div class="line"><span class="preprocessor">#ifdef ENGINE_DLL</span></div><div class="line">            GetEngineFactoryD3D12Type GetEngineFactoryD3D12 = <span class="keyword">nullptr</span>;</div><div class="line">            <span class="comment">// Load the dll and import GetEngineFactoryD3D12() function</span></div><div class="line">            <a class="code" href="namespace_diligent.html#a8b3ac65ac7e5051a36f23aab198b7f26">LoadGraphicsEngineD3D12</a>(GetEngineFactoryD3D12);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">            <span class="keyword">auto</span> *pFactoryD3D12 = GetEngineFactoryD3D12();</div><div class="line">            EngineD3D12Attribs EngD3D12Attribs;</div><div class="line">            EngineD3D12Attribs.<a class="code" href="struct_diligent_1_1_engine_d3_d12_attribs.html#a922a172c8be3881a1b1480802ac3ec10">GPUDescriptorHeapDynamicSize</a>[0] = 32768;</div><div class="line">            EngineD3D12Attribs.GPUDescriptorHeapSize[1] = 128;</div><div class="line">            EngineD3D12Attribs.GPUDescriptorHeapDynamicSize[1] = 2048-128;</div><div class="line">            EngineD3D12Attribs.DynamicDescriptorAllocationChunkSize[0] = 32;</div><div class="line">            EngineD3D12Attribs.DynamicDescriptorAllocationChunkSize[1] = 8; <span class="comment">// D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER</span></div><div class="line">            pFactoryD3D12-&gt;CreateDeviceAndContextsD3D12( EngD3D12Attribs, ppRenderDevice, ppImmediateContext, 0);</div><div class="line">            pFactoryD3D12-&gt;CreateSwapChainD3D12( *ppRenderDevice, *ppImmediateContext, SCDesc, hWnd, ppSwapChain );</div><div class="line">        }</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> DeviceType::OpenGL:</div><div class="line">        {</div><div class="line"><span class="preprocessor">#ifdef ENGINE_DLL</span></div><div class="line">            <span class="comment">// Declare function pointer</span></div><div class="line">            GetEngineFactoryOpenGLType GetEngineFactoryOpenGL = <span class="keyword">nullptr</span>;</div><div class="line">            <span class="comment">// Load the dll and import GetEngineFactoryOpenGL() function</span></div><div class="line">            <a class="code" href="namespace_diligent.html#a4102302b39db6902d51501d66e2fcfe6">LoadGraphicsEngineOpenGL</a>(GetEngineFactoryOpenGL);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">            EngineCreationAttribs EngineCreationAttribs;</div><div class="line">            GetEngineFactoryOpenGL()-&gt;CreateDeviceAndSwapChainGL(</div><div class="line">                EngineCreationAttribs, ppRenderDevice, ppImmediateContext, SCDesc, hWnd, ppSwapChain );</div><div class="line">        }</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">            LOG_ERROR_AND_THROW(<span class="stringliteral">&quot;Unknown device type&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>On Windows, the engine can be statically linked to the application or built as a separate DLL. In the former case, factory functions <code>GetEngineFactoryOpenGL()</code>, <code>GetEngineFactoryD3D11()</code>, and <code>GetEngineFactoryD3D12()</code> can be called directly. In the latter case, you need to load the DLL into the process's address space using <code>LoadGraphicsEngineOpenGL()</code>, <code>LoadGraphicsEngineD3D11()</code> or <code>LoadGraphicsEngineD3D12()</code> function. Each function loads appropriate dynamic library and imports the functions required to initialize the engine. You need to include the following headers:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;RenderDeviceFactoryD3D11.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;RenderDeviceFactoryD3D12.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;RenderDeviceFactoryOpenGL.h&quot;</span></div></div><!-- fragment --><p> You also need to add the following directories to the include search paths:</p>
<ul>
<li>diligentcore/Graphics/GraphicsEngineD3D11/interface</li>
<li>diligentcore/Graphics/GraphicsEngineD3D12/interface</li>
<li>diligentcore/Graphics/GraphicsEngineOpenGL/interface</li>
</ul>
<p>Also, enable <a class="el" href="namespace_diligent.html" title="Namespace for the OpenGL implementation of the graphics engine. ">Diligent</a> namespace:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_diligent.html">Diligent</a>;</div></div><!-- fragment --><p><code>IEngineFactoryD3D11::CreateDeviceAndContextsD3D11()</code> and <code>IEngineFactoryD3D12::CreateDeviceAndContextsD3D12()</code> functions can also create a specified number of deferred contexts, which can be used for multi-threaded command recording. Deferred contexts can only be created during the initialization of the engine. The function populates an array of pointers to the contexts, where the immediate context goes at position 0, followed by all deferred contexts.</p>
<p>For more details, take a look at <a href="https://github.com/DiligentGraphics/DiligentSamples/blob/master/Samples/SampleBase/Src/Win32/WinMain.cpp">WinMain.cpp</a> file.</p>
<h3>Universal Windows Platform</h3>
<p>On Universal Windows Platform, you can create Direct3D11 or Direct3D12 device. Only static linking is currently supported, but dynamic linking can also be implemented. Initialization is performed the same way as on Win32 Platform. The difference is that you first create the render device and device contexts by calling <code>IEngineFactoryD3D11::CreateDeviceAndContextsD3D11()</code> or <code>IEngineFactoryD3D12::CreateDeviceAndContextsD3D12()</code>. The swap chain is created later by a call to <code>IEngineFactoryD3D11::CreateSwapChainD3D11()</code> or <code>IEngineFactoryD3D12::CreateSwapChainD3D12()</code>. Please look at the <a href="https://github.com/DiligentGraphics/DiligentSamples/blob/master/Samples/SampleBase/Src/UWP/Common/DeviceResources.cpp">DeviceResources.cpp</a> file for more details.</p>
<h3>Linux</h3>
<p>On Linux platform, the only API currently supported is OpenGL. Initialization of GL context on Linux is tightly coupled with window creation. As a result, <a class="el" href="namespace_diligent.html" title="Namespace for the OpenGL implementation of the graphics engine. ">Diligent</a> Engine does not initialize the context, but attaches to the one initialized by the app. An example of the engine initialization on Linux can be found in <a href="https://github.com/DiligentGraphics/DiligentSamples/blob/master/Samples/SampleBase/src/Linux/LinuxMain.cpp">LinuxMain.cpp</a>.</p>
<h3>Android</h3>
<p>On Android, you can only create OpenGLES device. The following code snippet shows an example:</p>
<div class="fragment"><div class="line">EngineCreationAttribs EngineCreationAttribs;</div><div class="line">RefCntAutoPtr&lt;IRenderDevice&gt; pRenderDevice;</div><div class="line">SwapChainDesc SwapChainDesc;</div><div class="line"><span class="keyword">auto</span> pFactory = GetEngineFactoryOpenGL();</div><div class="line">pFactory-&gt;CreateDeviceAndSwapChainGL( EngineCreationAttribs, &amp;pRenderDevice, &amp;pDeviceContext_, </div><div class="line">                                      SwapChainDesc, app_-&gt;window, &amp;pSwapChain_ );</div><div class="line"></div><div class="line">IRenderDeviceGLES *pRenderDeviceOpenGLES;</div><div class="line">pRenderDevice-&gt;QueryInterface( IID_RenderDeviceGLES, reinterpret_cast&lt;IObject**&gt;(&amp;pRenderDeviceOpenGLES) );</div></div><!-- fragment --><p>If engine is built as dynamic library, the library needs to be loaded by the native activity. The following code shows one possible way:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span></div><div class="line">{</div><div class="line">    <span class="keywordflow">try</span>{</div><div class="line">        System.loadLibrary(<span class="stringliteral">&quot;GraphicsEngineOpenGL&quot;</span>);</div><div class="line">    } <span class="keywordflow">catch</span> (UnsatisfiedLinkError e) {</div><div class="line">        Log.e(<span class="stringliteral">&quot;native-activity&quot;</span>, <span class="stringliteral">&quot;Failed to load GraphicsEngineOpenGL library.\n&quot;</span> + e);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3>Attaching to Already Initialized Graphics API</h3>
<p>An alternative way to initialize the engine is to attach to existing D3D11/D3D12 device or OpenGL/GLES context. Refer to <a href="http://diligentgraphics.com/diligent-engine/native-api-interoperability/">Native API interoperability</a> for more details.</p>
<h2>Creating Resources</h2>
<p>Device resources are created by the render device. The two main resource types are buffers, which represent linear memory, and textures, which use memory layouts optimized for fast filtering. To create a buffer, you need to populate <code>BufferDesc</code> structure and call <code>IRenderDevice::CreateBuffer()</code>. The following code creates a uniform (constant) buffer:</p>
<div class="fragment"><div class="line">BufferDesc BuffDesc;</div><div class="line">BufferDesc.Name = <span class="stringliteral">&quot;Uniform buffer&quot;</span>;</div><div class="line">BuffDesc.BindFlags = <a class="code" href="namespace_diligent.html#ad748ff5bd670e021d6e29182b530cbceac2120e5b46a9b5611f937fb446d099f9">BIND_UNIFORM_BUFFER</a>;</div><div class="line">BuffDesc.Usage = <a class="code" href="namespace_diligent.html#a5342fb015dbf7f2e638dbfccc325a746a99a6c4fe39b32dc6f6f247554fa2eb1c">USAGE_DYNAMIC</a>;</div><div class="line">BuffDesc.uiSizeInBytes = <span class="keyword">sizeof</span>(ShaderConstants);</div><div class="line">BuffDesc.CPUAccessFlags = <a class="code" href="namespace_diligent.html#a0f62a9270b7cb35023bfb7ff6318bd01a73d498f881235bb1efddb57352f0d5ca">CPU_ACCESS_WRITE</a>;</div><div class="line">m_pDevice-&gt;CreateBuffer( BuffDesc, BufferData(), &amp;m_pConstantBuffer );</div></div><!-- fragment --><p>Similar, to create a texture, populate <code>TextureDesc</code> structure and call <code>IRenderDevice::CreateTexture()</code> as in the following example:</p>
<div class="fragment"><div class="line">TextureDesc TexDesc;</div><div class="line">TexDesc.Name = <span class="stringliteral">&quot;My texture 2D&quot;</span>;</div><div class="line">TexDesc.Type = TEXTURE_TYPE_2D;</div><div class="line">TexDesc.Width = 1024;</div><div class="line">TexDesc.Height = 1024;</div><div class="line">TexDesc.Format = <a class="code" href="namespace_diligent.html#ad7f1ec9812f01bc86834b408c5857465a0bdd5c2150977a0d9092831c1f45e61b">TEX_FORMAT_RGBA8_UNORM</a>;</div><div class="line">TexDesc.Usage = <a class="code" href="namespace_diligent.html#a5342fb015dbf7f2e638dbfccc325a746ae6658ba1c8f4426a8b0bdae1b7e3ae64">USAGE_DEFAULT</a>;</div><div class="line">TexDesc.BindFlags = <a class="code" href="namespace_diligent.html#ad748ff5bd670e021d6e29182b530cbceaef09415507884d7beea9a716e824a138">BIND_SHADER_RESOURCE</a> | <a class="code" href="namespace_diligent.html#ad748ff5bd670e021d6e29182b530cbcea4154c60d5487f7cded7fc1ef4a1bba89">BIND_RENDER_TARGET</a> | <a class="code" href="namespace_diligent.html#ad748ff5bd670e021d6e29182b530cbceaf4c7e9aeccba22f01ef46f348551fd0c">BIND_UNORDERED_ACCESS</a>;</div><div class="line">TexDesc.Name = <span class="stringliteral">&quot;Sample 2D Texture&quot;</span>;</div><div class="line">m_pRenderDevice-&gt;CreateTexture( TexDesc, TextureData(), &amp;m_pTestTex );</div></div><!-- fragment --><p>There is only one function <code>CreateTexture()</code> that is capable of creating all types of textures. Type, format, array size and all other parameters are specified by the members of the <code>TextureDesc</code> structure.</p>
<p>For every bind flag specified during the texture creation time, the texture object creates a default view. Default shader resource view addresses the entire texture, default render target and depth stencil views reference all array slices in the most detailed mip level, and unordered access view references the entire texture. To get a default view from the texture, use <code>ITexture::GetDefaultView()</code> function. Note that this function does not increase reference counter on the returned interface. You can create additional texture views using <code>ITexture::CreateView()</code>. Use <code>IBuffer::CreateView()</code> to create additional views of a buffer.</p>
<h2>Initializing Pipeline State</h2>
<p><a class="el" href="namespace_diligent.html" title="Namespace for the OpenGL implementation of the graphics engine. ">Diligent</a> Engine follows Direct3D12 style to configure the graphics/compute pipeline. One big Pipelines State Object (PSO) encompasses all required states (all shader stages, input layout description, depth stencil, rasterizer and blend state descriptions etc.)</p>
<h3>Creating Shaders</h3>
<p>To create a shader, populate <code>ShaderCreationAttribs</code> structure. There are two ways to create a shader. The first way is to provide a pointer to the shader source code through <code>ShaderCreationAttribs::Source</code> member. The second way is to provide a file name. Graphics Engine is entirely decoupled from the platform. Since the host file system is platform-dependent, the structure exposes <code>ShaderCreationAttribs::pShaderSourceStreamFactory</code> member that is intended to provide the engine access to the file system. If you provided the source file name, you must also provide non-null pointer to the shader source stream factory. If the shader source contains any <code>#include</code> directives, the source stream factory will also be used to load these files. The engine provides default implementation for every supported platform that should be sufficient in most cases. You can however define your own implementation.</p>
<p>An important member is <code>ShaderCreationAttribs::SourceLanguage</code>. The following are valid values for this member:</p>
<ul>
<li><code>SHADER_SOURCE_LANGUAGE_DEFAULT</code> - The shader source format matches the underlying graphics API: HLSL for D3D11 or D3D12 mode, and GLSL for OpenGL and OpenGLES modes.</li>
<li><code>SHADER_SOURCE_LANGUAGE_HLSL</code> - The shader source is in HLSL. For OpenGL and OpenGLES modes, the source code will be converted to GLSL. See shader converter for details.</li>
<li><code>SHADER_SOURCE_LANGUAGE_GLSL</code> - The shader source is in GLSL. There is currently no GLSL to HLSL converter.</li>
</ul>
<p>To allow grouping of resources based on the frequency of expected change, <a class="el" href="namespace_diligent.html" title="Namespace for the OpenGL implementation of the graphics engine. ">Diligent</a> Engine introduces classification of shader variables:</p>
<ul>
<li>Static variables (<code>SHADER_VARIABLE_TYPE_STATIC</code>) are variables that are expected to be set only once. They may not be changed once a resource is bound to the variable. Such variables are intended to hold global constants such as camera attributes or global light attributes constant buffers.</li>
<li>Mutable variables (<code>SHADER_VARIABLE_TYPE_MUTABLE</code>) define resources that are expected to change on a per-material frequency. Examples may include diffuse textures, normal maps etc.</li>
<li>Dynamic variables (<code>SHADER_VARIABLE_TYPE_DYNAMIC</code>) are expected to change frequently and randomly.</li>
</ul>
<p><a href="http://diligentgraphics.com/2016/03/23/resource-binding-model-in-diligent-engine-2-0">This post</a> gives more details about the resource binding model in <a class="el" href="namespace_diligent.html" title="Namespace for the OpenGL implementation of the graphics engine. ">Diligent</a> Engine. To define variable types, prepare an array of <code>ShaderVariableDesc</code> structures and initialize <code>ShaderCreationAttribs::Desc::VariableDesc</code> and <code>ShaderCreationAttribs::Desc::NumVariables</code>. Also <code>ShaderCreationAttribs::Desc::DefaultVariableType</code> can be used to set the type that will be used if variable name is not provided.</p>
<p>When creating a shader, textures can be assigned static samplers. If static sampler is assigned, it will always be used instead of the one initialized in the texture shader resource view. To initialize static samplers, prepare an array of <code>StaticSamplerDesc</code> structures and intialize <code>ShaderCreationAttribs::Desc::StaticSamplers</code> and <code>ShaderCreationAttribs::Desc::NumStaticSamplers</code>. Notice that static samplers can be assigned to texture variable of any type, not necessarily static. It is highly recommended to use static samplers whenever possible.</p>
<p>Other members of the <code>ShaderCreationAttribs</code> structure define shader include search directories, shader macro definitions, shader entry point and other parameters. The following is an example of shader initialization:</p>
<div class="fragment"><div class="line">ShaderCreationAttribs Attrs;</div><div class="line">Attrs.Desc.Name = <span class="stringliteral">&quot;MyPixelShader&quot;</span>;</div><div class="line">Attrs.FilePath = <span class="stringliteral">&quot;MyShaderFile.fx&quot;</span>;</div><div class="line">Attrs.SearchDirectories = <span class="stringliteral">&quot;shaders;shaders\\inc;&quot;</span>;</div><div class="line">Attrs.EntryPoint = <span class="stringliteral">&quot;MyPixelShader&quot;</span>;</div><div class="line">Attrs.Desc.ShaderType = <a class="code" href="namespace_diligent.html#a8294eb0a10dafa18441e78a80d231fd2a9d50afa47ec991c605f6cde4dd872c34">SHADER_TYPE_PIXEL</a>;</div><div class="line">Attrs.SourceLanguage = <a class="code" href="namespace_diligent.html#afefecb3e9dff6f9b8b9f00cd2770c7b0ae2902026c29ba5ceeec9a0bb4f25e111">SHADER_SOURCE_LANGUAGE_HLSL</a>;</div><div class="line">BasicShaderSourceStreamFactory BasicSSSFactory(Attrs.SearchDirectories);</div><div class="line">Attrs.pShaderSourceStreamFactory = &amp;BasicSSSFactory;</div><div class="line"></div><div class="line">ShaderVariableDesc ShaderVars[] = </div><div class="line">{</div><div class="line">    {<span class="stringliteral">&quot;g_StaticTexture&quot;</span>, <a class="code" href="namespace_diligent.html#adea6ddf55230a2722e6a7401e18de698a4c137d58eb6a965d1feb648e387a9ec3">SHADER_VARIABLE_TYPE_STATIC</a>},</div><div class="line">    {<span class="stringliteral">&quot;g_MutableTexture&quot;</span>, <a class="code" href="namespace_diligent.html#adea6ddf55230a2722e6a7401e18de698a13c8763ed8f1413ee5d8b3d98c895c3a">SHADER_VARIABLE_TYPE_MUTABLE</a>},</div><div class="line">    {<span class="stringliteral">&quot;g_DynamicTexture&quot;</span>, <a class="code" href="namespace_diligent.html#adea6ddf55230a2722e6a7401e18de698a8f878878823106ce70c825475ef7ca16">SHADER_VARIABLE_TYPE_DYNAMIC</a>}</div><div class="line">};</div><div class="line">Attrs.Desc.VariableDesc = ShaderVars;</div><div class="line">Attrs.Desc.NumVariables = _countof(ShaderVars);</div><div class="line">Attrs.Desc.DefaultVariableType = <a class="code" href="namespace_diligent.html#adea6ddf55230a2722e6a7401e18de698a4c137d58eb6a965d1feb648e387a9ec3">SHADER_VARIABLE_TYPE_STATIC</a>;</div><div class="line"></div><div class="line">StaticSamplerDesc StaticSampler;</div><div class="line">StaticSampler.Desc.MinFilter = <a class="code" href="namespace_diligent.html#a9001a5a822d4d0901acdc2c8cbe600b3a167655f3ace23033921e2e4066796751">FILTER_TYPE_LINEAR</a>;</div><div class="line">StaticSampler.Desc.MagFilter = <a class="code" href="namespace_diligent.html#a9001a5a822d4d0901acdc2c8cbe600b3a167655f3ace23033921e2e4066796751">FILTER_TYPE_LINEAR</a>;</div><div class="line">StaticSampler.Desc.MipFilter = <a class="code" href="namespace_diligent.html#a9001a5a822d4d0901acdc2c8cbe600b3a167655f3ace23033921e2e4066796751">FILTER_TYPE_LINEAR</a>;</div><div class="line">StaticSampler.TextureName = <span class="stringliteral">&quot;g_MutableTexture&quot;</span>;</div><div class="line">Attrs.Desc.NumStaticSamplers = 1;</div><div class="line">Attrs.Desc.StaticSamplers = &amp;StaticSampler;</div><div class="line"></div><div class="line">ShaderMacroHelper Macros;</div><div class="line">Macros.AddShaderMacro(<span class="stringliteral">&quot;USE_SHADOWS&quot;</span>, 1);</div><div class="line">Macros.AddShaderMacro(<span class="stringliteral">&quot;NUM_SHADOW_SAMPLES&quot;</span>, 4);</div><div class="line">Macros.Finalize();</div><div class="line">Attrs.Macros = Macros;</div><div class="line"></div><div class="line">RefCntAutoPtr&lt;IShader&gt; pShader;</div><div class="line">m_pDevice-&gt;CreateShader( Attrs, &amp;pShader );</div></div><!-- fragment --><h3>Creating Pipeline State Object</h3>
<p>To create a pipeline state object, define instance of <code>PipelineStateDesc</code> structure:</p>
<div class="fragment"><div class="line">PipelineStateDesc PSODesc;</div></div><!-- fragment --><p>Describe the pipeline specifics such as if the pipeline is a compute pipeline, number and format of render targets as well as depth-stencil format:</p>
<div class="fragment"><div class="line"><span class="comment">// This is a graphics pipeline</span></div><div class="line">PSODesc.IsComputePipeline = <span class="keyword">false</span>;</div><div class="line">PSODesc.GraphicsPipeline.NumRenderTargets = 1;</div><div class="line">PSODesc.GraphicsPipeline.RTVFormats[0] = <a class="code" href="namespace_diligent.html#ad7f1ec9812f01bc86834b408c5857465a86a2e99aecff070023e1dd0331fb9a95">TEX_FORMAT_RGBA8_UNORM_SRGB</a>;</div><div class="line">PSODesc.GraphicsPipeline.DSVFormat = <a class="code" href="namespace_diligent.html#ad7f1ec9812f01bc86834b408c5857465ac2f008275b02ec4c7a85ac5da386958b">TEX_FORMAT_D32_FLOAT</a>;</div></div><!-- fragment --><p>Initialize depth-stencil state description structure DepthStencilStateDesc. Note that the constructor initializes the members with default values and you can only set the ones that are different from default.</p>
<div class="fragment"><div class="line"><span class="comment">// Init depth-stencil state</span></div><div class="line">DepthStencilStateDesc &amp;DepthStencilDesc = PSODesc.GraphicsPipeline.DepthStencilDesc;</div><div class="line">DepthStencilDesc.DepthEnable = <span class="keyword">true</span>;</div><div class="line">DepthStencilDesc.DepthWriteEnable = <span class="keyword">true</span>;</div></div><!-- fragment --><p>Initialize blend state description structure <code>BlendStateDesc</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// Init blend state</span></div><div class="line">BlendStateDesc &amp;BSDesc = PSODesc.GraphicsPipeline.BlendDesc;</div><div class="line">BSDesc.IndependentBlendEnable = False;</div><div class="line"><span class="keyword">auto</span> &amp;RT0 = BSDesc.RenderTargets[0];</div><div class="line">RT0.BlendEnable = True;</div><div class="line">RT0.RenderTargetWriteMask = <a class="code" href="namespace_diligent.html#a8dfef3a8f30375369b1ea5fe76abc35cafd8cebfdaacbc52fff4edae2102ced91">COLOR_MASK_ALL</a>;</div><div class="line">RT0.SrcBlend    = <a class="code" href="namespace_diligent.html#a781bf760ca4b6e5258059a857c2f70b1a948b5c73475cba94c6c028092f2b9e3a">BLEND_FACTOR_SRC_ALPHA</a>;</div><div class="line">RT0.DestBlend   = <a class="code" href="namespace_diligent.html#a781bf760ca4b6e5258059a857c2f70b1a5bb6a5588766529cd50db693951fc976">BLEND_FACTOR_INV_SRC_ALPHA</a>;</div><div class="line">RT0.BlendOp     =  <a class="code" href="namespace_diligent.html#a1a15723d053d87194d02437ffd2f55f3a9e84f0b1a683c460a49427cdc716a531">BLEND_OPERATION_ADD</a>;</div><div class="line">RT0.SrcBlendAlpha   = <a class="code" href="namespace_diligent.html#a781bf760ca4b6e5258059a857c2f70b1a948b5c73475cba94c6c028092f2b9e3a">BLEND_FACTOR_SRC_ALPHA</a>;</div><div class="line">RT0.DestBlendAlpha  = <a class="code" href="namespace_diligent.html#a781bf760ca4b6e5258059a857c2f70b1a5bb6a5588766529cd50db693951fc976">BLEND_FACTOR_INV_SRC_ALPHA</a>;</div><div class="line">RT0.BlendOpAlpha    = <a class="code" href="namespace_diligent.html#a1a15723d053d87194d02437ffd2f55f3a9e84f0b1a683c460a49427cdc716a531">BLEND_OPERATION_ADD</a>;</div></div><!-- fragment --><p>Initialize rasterizer state description structure <code>RasterizerStateDesc</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// Init rasterizer state</span></div><div class="line">RasterizerStateDesc &amp;RasterizerDesc = PSODesc.GraphicsPipeline.RasterizerDesc;</div><div class="line">RasterizerDesc.FillMode = <a class="code" href="namespace_diligent.html#a3b85032ce91db5b8f9bcaab7bff02bc9a384ecd536cf5805995b7f7e2732ee0bf">FILL_MODE_SOLID</a>;</div><div class="line">RasterizerDesc.CullMode = <a class="code" href="namespace_diligent.html#aeeda8d41835aaaca5142122552880896a88bffa666bf1f0913c785f5adcc51a3c">CULL_MODE_NONE</a>;</div><div class="line">RasterizerDesc.FrontCounterClockwise = True;</div><div class="line">RasterizerDesc.ScissorEnable = True;</div><div class="line"><span class="comment">//RSDesc.MultisampleEnable = false; // do not allow msaa (fonts would be degraded)</span></div><div class="line">RasterizerDesc.AntialiasedLineEnable = False;</div></div><!-- fragment --><p>Initialize input layout description structure <code>InputLayoutDesc</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// Define input layout</span></div><div class="line">InputLayoutDesc &amp;Layout = PSODesc.GraphicsPipeline.InputLayout;</div><div class="line">LayoutElement TextLayoutElems[] = </div><div class="line">{</div><div class="line">    LayoutElement( 0, 0, 3, VT_FLOAT32, False ),</div><div class="line">    LayoutElement( 1, 0, 4, VT_UINT8, True ),</div><div class="line">    LayoutElement( 2, 0, 2, VT_FLOAT32, False ),</div><div class="line">};</div><div class="line">Layout.LayoutElements = TextLayoutElems;</div><div class="line">Layout.NumElements = _countof( TextLayoutElems );</div></div><!-- fragment --><p>Finally, define primitive topology type, set shaders and call <code>IRenderDevice::CreatePipelineState()</code> to create the PSO:</p>
<div class="fragment"><div class="line"><span class="comment">// Define shader and primitive topology</span></div><div class="line">PSODesc.GraphicsPipeline.PrimitiveTopologyType = <a class="code" href="namespace_diligent.html#a2966e113686e1311912fd7b350721094abc916aeed560a57e484623c409c48d8f">PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE</a>;</div><div class="line">PSODesc.GraphicsPipeline.pVS = m_pTextVS;</div><div class="line">PSODesc.GraphicsPipeline.pPS = m_pTextPS;</div><div class="line"></div><div class="line">PSODesc.Name = <span class="stringliteral">&quot;My pipeline state&quot;</span>;</div><div class="line">m_pDev-&gt;CreatePipelineState(PSODesc, &amp;m_pPSO);</div></div><!-- fragment --><h2>Binding Shader Resources</h2>
<p><a href="http://diligentgraphics.com/2016/03/23/resource-binding-model-in-diligent-engine-2-0/">Shader resource binding in Diligent Engine</a> is based on grouping variables in 3 different groups (static, mutable and dynamic). Static variables are variables that are expected to be set only once. They may not be changed once a resource is bound to the variable. Such variables are intended to hold global constants such as camera attributes or global light attributes constant buffers. They are bound directly to the shader object:</p>
<div class="fragment"><div class="line">PixelShader-&gt;GetShaderVariable( <span class="stringliteral">&quot;g_tex2DShadowMap&quot;</span> )-&gt;Set( pShadowMapSRV );</div></div><!-- fragment --><p>Mutable and dynamic variables are bound via a new object called Shader Resource Binding (SRB), which is created by the pipeline state (<code>IPipelineState::CreateShaderResourceBinding()</code>):</p>
<div class="fragment"><div class="line">m_pPSO-&gt;CreateShaderResourceBinding(&amp;m_pSRB);</div></div><!-- fragment --><p>Dynamic and mutable resources are then bound through SRB object:</p>
<div class="fragment"><div class="line">m_pSRB-&gt;GetVariable(SHADER_TYPE_VERTEX, <span class="stringliteral">&quot;tex2DDiffuse&quot;</span>)-&gt;Set(pDiffuseTexSRV);</div><div class="line">m_pSRB-&gt;GetVariable(SHADER_TYPE_VERTEX, <span class="stringliteral">&quot;cbRandomAttribs&quot;</span>)-&gt;Set(pRandomAttrsCB);</div></div><!-- fragment --><p>The difference between mutable and dynamic resources is that mutable ones can only be set once for every instance of a shader resource binding. Dynamic resources can be set multiple times. It is important to properly set the variable type as this may affect performance. Static variables are generally most efficient, followed by mutable. Dynamic variables are most expensive from performance point of view.</p>
<p>An alternative way to bind shader resources is to create <code>IResourceMapping</code> interface that maps resource literal names to the actual resources:</p>
<div class="fragment"><div class="line">ResourceMappingEntry Entries[] = { </div><div class="line">    { <span class="stringliteral">&quot;g_Texture&quot;</span>, pTexture-&gt;GetDefaultView(TEXTURE_VIEW_SHADER_RESOURCE)},</div><div class="line">    ResourceMappingEntry() </div><div class="line">};</div><div class="line">ResourceMappingDesc ResMappingDesc;</div><div class="line">ResMappingDesc.pEntries= Entries;</div><div class="line">RefCntAutoPtr&lt;IResourceMapping&gt; pResMapping;</div><div class="line">pRenderDevice-&gt;CreateResourceMapping( ResMappingDesc, &amp;pResMapping );</div></div><!-- fragment --><p>The resource mapping can then be used to bind all resources in a shader (<code>IShader::BindResources()</code>):</p>
<div class="fragment"><div class="line">pPixelShader-&gt;BindResources(pResMapping, BIND_SHADER_RESOURCES_ALL_RESOLVED);</div></div><!-- fragment --><p>in a shader resource binding (<code>IShaderResourceBinding::BindResources()</code>):</p>
<div class="fragment"><div class="line">m_pSRB-&gt;BindResources(SHADER_TYPE_VERTEX|SHADER_TYPE_PIXEL, pResMapping, BIND_SHADER_RESOURCES_ALL_RESOLVED);</div></div><!-- fragment --><p>or in a pipeline state (<code>IPipelineState::BindShaderResources()</code>):</p>
<div class="fragment"><div class="line">m_pPSO-&gt;BindResources(pResMapping, BIND_SHADER_RESOURCES_ALL_RESOLVED);</div></div><!-- fragment --><p>The last parameter to all <code>BindResources()</code> functions defines how resources should be resolved:</p>
<ul>
<li><code>BIND_SHADER_RESOURCES_RESET_BINDINGS</code> - Reset all bindings. If this flag is specified, all bindings will be reset to null before new bindings are set. By default all existing bindings are preserved.</li>
<li><code>BIND_SHADER_RESOURCES_UPDATE_UNRESOLVED</code> - If this flag is specified, only unresolved bindings will be updated. All resolved bindings will keep their original values. If this flag is not specified, every shader variable will be updated if the mapping contains corresponding resource.</li>
<li><code>BIND_SHADER_RESOURCES_ALL_RESOLVED</code> - If this flag is specified, all shader bindings are expected be resolved after the call. If this is not the case, debug error will be displayed.</li>
</ul>
<p><code>BindResources()</code> may be called several times with different resource mappings to bind resources. However, it is recommended to use one large resource mapping as the size of the mapping does not affect element search time.</p>
<p>The engine performs run-time checks to verify that correct resources are being bound. For example, if you try to bind a constant buffer to a shader resource view variable, an error will be output to the debug console.</p>
<h2>Setting the Pipeline State and Invoking Draw Command</h2>
<p>Before any draw command can be invoked, all required vertex and index buffers as well as the pipeline state should be bound to the device context:</p>
<div class="fragment"><div class="line"><span class="comment">// Clear render target</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> zero[4] = {0, 0, 0, 0};</div><div class="line">m_pContext-&gt;ClearRenderTarget(<span class="keyword">nullptr</span>, zero);</div><div class="line"></div><div class="line"><span class="comment">// Set vertex and index buffers</span></div><div class="line">IBuffer *buffer[] = {m_pVertexBuffer};</div><div class="line">Uint32 offsets[] = {0};</div><div class="line">Uint32 strides[] = {<span class="keyword">sizeof</span>(MyVertex)};</div><div class="line">m_pContext-&gt;SetVertexBuffers(0, 1, buffer, strides, offsets, SET_VERTEX_BUFFERS_FLAG_RESET);</div><div class="line">m_pContext-&gt;SetIndexBuffer(m_pIndexBuffer, 0);</div><div class="line"></div><div class="line">m_pContext-&gt;SetPipelineState(m_pPSO);</div></div><!-- fragment --><p>Also, all shader resources must be committed to the device context. This is accomplished by the <code>IDeviceContext::CommitShaderResources()</code> method:</p>
<div class="fragment"><div class="line">m_pContext-&gt;CommitShaderResources(m_pSRB, COMMIT_SHADER_RESOURCES_FLAG_TRANSITION_RESOURCES);</div></div><!-- fragment --><p>If the method is not called, the engine will detect that resources are not committed and output debug message. Note that <code>CommitShaderResources()</code> must be called after the right pipeline state has been bound to the context. Note that the last parameter tells the system to transition resources to the correct states. If this flag is not specified, the resources must be explicitly transitioned to the right states by a call to <code>IDeviceContext::TransitionShaderResources()</code>:</p>
<div class="fragment"><div class="line">m_pContext-&gt;TransitionShaderResources(m_pPSO, m_pSRB);</div></div><!-- fragment --><p>Note that the method requires pointer to the pipeline state that created the shader resource binding.</p>
<p>When all required states and resources are bound, <code>IDeviceContext::Draw()</code> can be used to execute draw command or <code>IDeviceContext::DispatchCompute()</code> can be used to execute compute command. Note that for a draw command, graphics pipeline must be bound, and for dispatch command, compute pipeline must be bound. <code>Draw()</code> takes <code>DrawAttribs</code> structure as an argument. The structure members define all attributes required to perform the command (primitive topology, number of vertices or indices, if draw call is indexed or not, if draw call is instanced or not, if draw call is indirect or not, etc.). For example:</p>
<div class="fragment"><div class="line">DrawAttribs attrs;</div><div class="line">attrs.IsIndexed = <span class="keyword">true</span>;</div><div class="line">attrs.IndexType = <a class="code" href="namespace_diligent.html#a1d12e97c6da58b2d4dd003db4a8a957aa0e15f9d0c65df848ae20a42d67b78ee2">VT_UINT16</a>;</div><div class="line">attrs.NumIndices = 36;</div><div class="line">attrs.Topology = <a class="code" href="namespace_diligent.html#ae132e96b4b52bcb52026444873a794c5ae92cbcbf18a66dbe4463436512255d71">PRIMITIVE_TOPOLOGY_TRIANGLE_LIST</a>;</div><div class="line">pContext-&gt;Draw(attrs);</div></div><!-- fragment --><p><code>DispatchCompute()</code> takes DispatchComputeAttribs structure that defines compute grid dimensions:</p>
<div class="fragment"><div class="line">m_pContext-&gt;SetPipelineState(m_pComputePSO);</div><div class="line">m_pContext-&gt;CommitShaderResources(m_pComputeSRB, COMMIT_SHADER_RESOURCES_FLAG_TRANSITION_RESOURCES);</div><div class="line">DispatchComputeAttribs DispatchAttrs(64, 64, 8);</div><div class="line">m_pContext-&gt;DispatchCompute(DispatchAttrs);</div></div><!-- fragment --><p>You can learn more about the engine API by looking at the <a href="http://diligentgraphics.com/diligent-engine/samples/">engine samples' source code</a> and the <a href="http://diligentgraphics.com/diligent-engine/api-reference/">API Reference</a>.</p>
<h1>Low-level API interoperability</h1>
<p><a class="el" href="namespace_diligent.html" title="Namespace for the OpenGL implementation of the graphics engine. ">Diligent</a> Engine extensively supports interoperability with underlying low-level APIs. The engine can be initialized by attaching to existing D3D11/D3D12 device or OpenGL/GLES context and provides access to the underlying native API objects. Refer to the following pages for more information:</p>
<p><a href="http://diligentgraphics.com/diligent-engine/native-api-interoperability/direct3d11-interoperability/">Direct3D11 Interoperability</a></p>
<p><a href="http://diligentgraphics.com/diligent-engine/native-api-interoperability/direct3d12-interoperability/">Direct3D12 Interoperability</a></p>
<p><a href="http://diligentgraphics.com/diligent-engine/native-api-interoperability/openglgles-interoperability/">OpenGL/GLES Interoperability</a></p>
<h1>References</h1>
<p><a href="http://diligentgraphics.com/diligent-engine/">Dilgeint Engine</a>. <a href="http://diligentgraphics.com/diligent-engine/api-basics/">API Basics</a>. <a href="http://diligentgraphics.com/diligent-engine/architecture/">Diligent Engine Architecture</a>.</p>
<h1>Version History</h1>
<h2>Current Progress</h2>
<ul>
<li>Removed legacy Visual Studio solution and project files</li>
</ul>
<h2>v2.1.a</h2>
<ul>
<li>Refactored build system to use CMake</li>
<li>Added support for Linux platform</li>
</ul>
<h2>v2.1</h2>
<h3>New Features</h3>
<h4>Core</h4>
<ul>
<li>Interoperability with native API ** Accessing internal objects and handles ** Createing diligent engine buffers/textures from native resources ** Attaching to existing D3D11/D3D12 device or GL context ** Resource state and command queue synchronization for D3D12</li>
<li>Integraion with Unity</li>
<li>Geometry shader support</li>
<li>Tessellation support</li>
<li>Performance optimizations</li>
</ul>
<h4>HLSL-&gt;GLSL converter</h4>
<ul>
<li>Support for structured buffers</li>
<li>HLSL-&gt;GLSL conversion is now a two-stage process: ** Creating conversion stream ** Creating GLSL source from the stream</li>
<li>Geometry shader support</li>
<li>Tessellation control and tessellation evaluation shader support</li>
<li>Support for non-void shader functions</li>
<li>Allowing structs as input parameters for shader functions</li>
</ul>
<h2>v2.0 (alpha)</h2>
<p>Alpha release of <a class="el" href="namespace_diligent.html" title="Namespace for the OpenGL implementation of the graphics engine. ">Diligent</a> Engine 2.0. The engine has been updated to take advantages of Direct3D12:</p>
<ul>
<li>Pipeline State Object encompasses all coarse-grain state objects like Depth-Stencil State, Blend State, Rasterizer State, shader states etc.</li>
<li>New shader resource binding model implemented to leverage Direct3D12</li>
<li>OpenGL and Direct3D11 backends</li>
<li>Alpha release is only available on Windows platform</li>
<li>Direct3D11 backend is very thoroughly optimized and has very low overhead compared to native D3D11 implementation</li>
<li>Direct3D12 implementation is preliminary and not yet optimized</li>
</ul>
<h3>v1.0.0</h3>
<p>Initial release</p>
<h1>License</h1>
<p>Licensed under the <a href="License.txt">Apache License, Version 2.0</a></p>
<h1>References</h1>
<p><a href="http://diligentgraphics.com">Diligent Graphics on the Web</a></p>
<p><a href="https://twitter.com/diligentengine">Diligent Graphics on Twitter</a></p>
<p><a href="https://www.facebook.com/DiligentGraphics/">Diligent Graphics on Facebook</a></p>
<p><b>Copyright 2015-2017 Egor Yusov</b> </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<!--
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 3 2018 20:17:31 for Diligent Engine API Reference by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
-->
</body>
</html>
